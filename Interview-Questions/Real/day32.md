### 마이크로태스크 큐

- 프라미스 핸들러 .then/catch/finally는 항상 비동기적으로 실행됩니다.
- 프라미스가 즉시 이행되더라도 .then/catch/finally 아래에 있는 코드는 이 핸들러들이 실행되기 전에 실행됩니다.

```js
let promise = Promise.resolve();
promise.then(() => alert("프라미스 성공!"));
alert("코드 종료"); // 얼럿 창이 가장 먼저 뜹니다.

// 왜 .then이 나중에 트리거 되었을까요? 그 이유에 대해 알아봅시다.
```

- 비동기 작업을 처리하려면 적절한 관리가 필요합니다. 이를 위해 ECMA에선 PromiseJobs라는 내부 큐(internal queue)를 명시합니다. V8 엔진에선 이를 '마이크로태스크 큐(microtask queue)'라고 부르기 때문에 이 용어가 좀 더 선호됩니다.

- 마이크로태스크 큐는 먼저 들어온 작업을 먼저 실행합니다(FIFO, first-in-first-out).
- 실행할 것이 아무것도 남아있지 않을 때만 => 마이크로태스크 큐에 있는 작업이 실행되기 시작합니다.

- 요약하자면, 어떤 프라미스가 준비되었을 때 이 프라미스의 .then/catch/finally 핸들러가 큐에 들어간다고 생각하시면 됩니다. 이때 핸들러들은 여전히 실행되지 않습니다. 현재 코드에서 자유로운 상태가 되었을 때에서야 자바스크립트 엔진은 큐에서 작업을 꺼내 실행합니다.

```js
promise.then(handler); // ===> 핸들러가 큐에 저장됨(enqueue)
alert("코드 종료");

// 스크립트 실행이 끝나야 큐에 저장된 핸들러가 실행됨
// 프라미스 핸들러는 항상 내부 큐를 통과하게 됩니다.
// 여러 개의 .then/catch/finally를 사용해 만든 체인의 경우, 각 핸들러는 비동기적으로 실행됩니다. 큐에 들어간 핸들러 각각은 현재 코드가 완료되고, 큐에 적체된 이전 핸들러의 실행이 완료되었을 때 실행됩니다.
```

### TEST

- 그렇다면 '프라미스 성공!'을 먼저, '코드 종료’를 나중에 출력되게 하려면 어떻게 해야 할까요? 실행 순서가 중요한 경우엔 이런 요구사항이 충족되도록 코드를 작성해야 합니다.
- 방법은 아주 쉽습니다. .then을 사용해 큐에 넣으면 됩니다.

```js
Promise.resolve()
  .then(() => alert("프라미스 성공!"))
  .then(() => alert("코드 종료"));
```

### 요약

- 모든 프라미스 동작은 ‘마이크로태스크 큐’(ES8 용어)라 불리는 내부 => ‘프라미스 잡(promise job)’ 큐에 들어가서 처리되기 때문에 => 프라미스 핸들링은 => 항상 비동기로 처리된다.

- 따라서 .then/catch/finally 핸들러는 항상 현재 코드가 종료되고 난 후에 호출된다.
- 어떤 코드 조각을 .then/catch/finally가 호출된 이후에 실행하고 싶다면 .then을 체인에 추가하고 이 안에 코드 조각을 넣으면 된다.
- 브라우저와 Node.js를 포함한 대부분의 자바스크립트 엔진에선 마이크로태스크가 '이벤트 루프(event loop)'와 '매크로태스크(macrotask)'와 깊은 연관 관계를 맺는다. 이 둘은 프라미스와는 직접적인 연관성이 없다.
